Help on module camera_calculator:

NAME
    camera_calculator

CLASSES
    builtins.object
        Images
    rclpy.node.Node(builtins.object)
        CameraCalculator
    
    class CameraCalculator(rclpy.node.Node)
     |  This is a class to run calculations on the camera images. Like making pointclouds from them and 
     |  getting the world coordinates of a pixel in the image. This intended to make it easier for students to write logic
     |  to find things in the image and move the robot arm.
     |  
     |  Args:
     |      Node (_type_): _description_
     |  
     |  Method resolution order:
     |      CameraCalculator
     |      rclpy.node.Node
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self)
     |      Create a Node.
     |      
     |      :param node_name: A name to give to this node. Validated by :func:`validate_node_name`.
     |      :param context: The context to be associated with, or ``None`` for the default global
     |          context.
     |      :param cli_args: A list of strings of command line args to be used only by this node.
     |          These arguments are used to extract remappings used by the node and other ROS specific
     |          settings, as well as user defined non-ROS arguments.
     |      :param namespace: The namespace to which relative topic and service names will be prefixed.
     |          Validated by :func:`validate_namespace`.
     |      :param use_global_arguments: ``False`` if the node should ignore process-wide command line
     |          args.
     |      :param enable_rosout: ``False`` if the node should ignore rosout logging.
     |      :param start_parameter_services: ``False`` if the node should not create parameter
     |          services.
     |      :param parameter_overrides: A list of overrides for initial values for parameters declared
     |          on the node.
     |      :param allow_undeclared_parameters: True if undeclared parameters are allowed.
     |          This flag affects the behavior of parameter-related operations.
     |      :param automatically_declare_parameters_from_overrides: If True, the "parameter overrides"
     |          will be used to implicitly declare parameters on the node during creation.
     |  
     |  color_img_cb(self, msg)
     |  
     |  color_img_info_cb(self, msg)
     |  
     |  depth_img_cb(self, msg)
     |  
     |  depth_img_info_cb(self, msg)
     |  
     |  display_images(self, img: camera_calculator.Images, markpoint_u_v: Optional[Tuple[int, int]] = None)
     |      Helper function to display an image pair and optionally to mark a point on the image with a cross.
     |      
     |      Args:
     |          img (Images): _description_
     |          markpoint_u_v (Optional[Tuple[int, int]], optional): _description_. Defaults to None.
     |  
     |  get_3d_points(self, color_img: numpy.ndarray[typing.Any, numpy.dtype[float]], depth_img: numpy.ndarray[typing.Any, numpy.dtype[float]], intrinsics: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]]) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]
     |      Helper function to get a pointcloud from an image pair and intrinsics. In the Camera frame. It will then take the RGB element and 
     |      pack those 3 bytes into a 4 byte float in a way that rviz2 can read.
     |      
     |      Args:
     |          color_img (npt.NDArray[float]): _description_
     |          depth_img (npt.NDArray[float]): _description_
     |          intrinsics (npt.NDArray): _description_
     |      
     |      Returns:
     |          npt.NDArray[np.float32]: _description_
     |  
     |  get_3d_points_from_pixel_point_on_color(self, img: camera_calculator.Images, u: int, v: int) -> Tuple[numpy.ndarray[Any, numpy.dtype[numpy.float32]], numpy.ndarray[Any, numpy.dtype[numpy.float32]]]
     |      Function to take image pair and intrinsics, and calculate the 3d location in world frame of a pixel. You could use a color mask or 
     |      contour stuff to get the center of an object in pixel coordinates, then pass it to this function to get the 3d location
     |      of the object in the world frame.
     |      
     |      Args:
     |          img (Images): image pair and intrinsics
     |          u (int): the u pixel coordinate. Note that in a numpy image the rows correspond to v, the columns to u.
     |          v (int): the v pixel coordinate. Note that in a numpy image the rows correspond to v, the columns to u.
     |      
     |      Returns:
     |          Tuple[npt.NDArray[np.float32], npt.NDArray[np.float32]]: the first array is points in the camera frame, second array is points in the world frame
     |  
     |  get_images(self) -> camera_calculator.Images
     |      Helper function to get an image pair and calculate the pointcloud. It will return None if not available, so check for that.
     |      
     |      Returns:
     |          Images: object with the image pair, intrinsics, and pointcloud. It's a chunky boy so don't keep too many in memory.
     |  
     |  points_to_pountcloud(self, xyz_rgb: numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]], frame_id: str) -> sensor_msgs.msg._point_cloud2.PointCloud2
     |      Helper function to take in a numpy pointcloud nx4, where the 4 is x, y, z, and a float containing RGB in a format for rviz.
     |      It packs this into a PointCloud2 object that can be published to ROS.
     |      
     |      Args:
     |          xyz_rgb (npt.NDArray[np.float32]): numpy pointcloud
     |          frame_id (str): what frame to use for the pointcloud.
     |      
     |      Returns:
     |          PointCloud2: _description_
     |  
     |  translate_to_world_frame(self, xyz_rgb: numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]) -> numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]]
     |      Helper function to translate a pointcloud with rgb data from camera to world frame.
     |      
     |      Args:
     |          xyz_rgb (npt.NDArray[np.float32]): nx4 array. the 4 is x, y, z, and a float containing r,g,b, compressed for rviz.
     |      
     |      Returns:
     |          _type_: npt.NDArray[np.float32]: nx4 array, in world coordinates.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from rclpy.node.Node:
     |  
     |  add_on_set_parameters_callback(self, callback: Callable[[List[rclpy.parameter.Parameter]], rcl_interfaces.msg._set_parameters_result.SetParametersResult]) -> None
     |      Add a callback in front to the list of callbacks.
     |      
     |      Calling this function will add a callback in self._parameter_callbacks list.
     |      
     |      It is considered bad practice to reject changes for "unknown" parameters as this prevents
     |      other parts of the node (that may be aware of these parameters) from handling them.
     |      
     |      :param callback: The function that is called whenever parameters are set for the node.
     |  
     |  add_waitable(self, waitable: rclpy.waitable.Waitable) -> None
     |      Add a class that is capable of adding things to the wait set.
     |      
     |      :param waitable: An instance of a waitable that the node will add to the waitset.
     |  
     |  count_publishers(self, topic_name: str) -> int
     |      Return the number of publishers on a given topic.
     |      
     |      `topic_name` may be a relative, private, or fully qualified topic name.
     |      A relative or private topic is expanded using this node's namespace and name.
     |      The queried topic name is not remapped.
     |      
     |      :param topic_name: the topic_name on which to count the number of publishers.
     |      :return: the number of publishers on the topic.
     |  
     |  count_subscribers(self, topic_name: str) -> int
     |      Return the number of subscribers on a given topic.
     |      
     |      `topic_name` may be a relative, private, or fully qualified topic name.
     |      A relative or private topic is expanded using this node's namespace and name.
     |      The queried topic name is not remapped.
     |      
     |      :param topic_name: the topic_name on which to count the number of subscribers.
     |      :return: the number of subscribers on the topic.
     |  
     |  create_client(self, srv_type, srv_name: str, *, qos_profile: rclpy.qos.QoSProfile = <rclpy.qos.QoSProfile object at 0x784876919bd0>, callback_group: rclpy.callback_groups.CallbackGroup = None) -> rclpy.client.Client
     |      Create a new service client.
     |      
     |      :param srv_type: The service type.
     |      :param srv_name: The name of the service.
     |      :param qos_profile: The quality of service profile to apply the service client.
     |      :param callback_group: The callback group for the service client. If ``None``, then the
     |          nodes default callback group is used.
     |  
     |  create_guard_condition(self, callback: Callable, callback_group: rclpy.callback_groups.CallbackGroup = None) -> rclpy.guard_condition.GuardCondition
     |      Create a new guard condition.
     |  
     |  create_publisher(self, msg_type, topic: str, qos_profile: Union[rclpy.qos.QoSProfile, int], *, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None, event_callbacks: Optional[rclpy.qos_event.PublisherEventCallbacks] = None, qos_overriding_options: Optional[rclpy.qos_overriding_options.QoSOverridingOptions] = None, publisher_class: Type[rclpy.publisher.Publisher] = <class 'rclpy.publisher.Publisher'>) -> rclpy.publisher.Publisher
     |      Create a new publisher.
     |      
     |      :param msg_type: The type of ROS messages the publisher will publish.
     |      :param topic: The name of the topic the publisher will publish to.
     |      :param qos_profile: A QoSProfile or a history depth to apply to the publisher.
     |        In the case that a history depth is provided, the QoS history is set to
     |        KEEP_LAST, the QoS history depth is set to the value
     |        of the parameter, and all other QoS settings are set to their default values.
     |      :param callback_group: The callback group for the publisher's event handlers.
     |          If ``None``, then the node's default callback group is used.
     |      :param event_callbacks: User-defined callbacks for middleware events.
     |      :return: The new publisher.
     |  
     |  create_rate(self, frequency: float, clock: rclpy.clock.Clock = None) -> rclpy.timer.Rate
     |      Create a Rate object.
     |      
     |      :param frequency: The frequency the Rate runs at (Hz).
     |      :param clock: The clock the Rate gets time from.
     |  
     |  create_service(self, srv_type, srv_name: str, callback: Callable[[~SrvTypeRequest, ~SrvTypeResponse], ~SrvTypeResponse], *, qos_profile: rclpy.qos.QoSProfile = <rclpy.qos.QoSProfile object at 0x784876919bd0>, callback_group: rclpy.callback_groups.CallbackGroup = None) -> rclpy.service.Service
     |      Create a new service server.
     |      
     |      :param srv_type: The service type.
     |      :param srv_name: The name of the service.
     |      :param callback: A user-defined callback function that is called when a service request
     |          received by the server.
     |      :param qos_profile: The quality of service profile to apply the service server.
     |      :param callback_group: The callback group for the service server. If ``None``, then the
     |          nodes default callback group is used.
     |  
     |  create_subscription(self, msg_type, topic: str, callback: Callable[[~MsgType], NoneType], qos_profile: Union[rclpy.qos.QoSProfile, int], *, callback_group: Optional[rclpy.callback_groups.CallbackGroup] = None, event_callbacks: Optional[rclpy.qos_event.SubscriptionEventCallbacks] = None, qos_overriding_options: Optional[rclpy.qos_overriding_options.QoSOverridingOptions] = None, raw: bool = False) -> rclpy.subscription.Subscription
     |      Create a new subscription.
     |      
     |      :param msg_type: The type of ROS messages the subscription will subscribe to.
     |      :param topic: The name of the topic the subscription will subscribe to.
     |      :param callback: A user-defined callback function that is called when a message is
     |          received by the subscription.
     |      :param qos_profile: A QoSProfile or a history depth to apply to the subscription.
     |        In the case that a history depth is provided, the QoS history is set to
     |        KEEP_LAST, the QoS history depth is set to the value
     |        of the parameter, and all other QoS settings are set to their default values.
     |      :param callback_group: The callback group for the subscription. If ``None``, then the
     |          nodes default callback group is used.
     |      :param event_callbacks: User-defined callbacks for middleware events.
     |      :param raw: If ``True``, then received messages will be stored in raw binary
     |          representation.
     |  
     |  create_timer(self, timer_period_sec: float, callback: Callable, callback_group: rclpy.callback_groups.CallbackGroup = None, clock: rclpy.clock.Clock = None) -> rclpy.timer.Timer
     |      Create a new timer.
     |      
     |      The timer will be started and every ``timer_period_sec`` number of seconds the provided
     |      callback function will be called.
     |      
     |      :param timer_period_sec: The period (s) of the timer.
     |      :param callback: A user-defined callback function that is called when the timer expires.
     |      :param callback_group: The callback group for the timer. If ``None``, then the nodes
     |          default callback group is used.
     |      :param clock: The clock which the timer gets time from.
     |  
     |  declare_parameter(self, name: str, value: Any = None, descriptor: Optional[rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor] = None, ignore_override: bool = False) -> rclpy.parameter.Parameter
     |      Declare and initialize a parameter.
     |      
     |      This method, if successful, will result in any callback registered with
     |      :func:`add_on_set_parameters_callback` to be called.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :param value: Value of the parameter to declare.
     |      :param descriptor: Descriptor for the parameter to declare.
     |      :param ignore_override: True if overrides shall not be taken into account; False otherwise.
     |      :return: Parameter with the effectively assigned value.
     |      :raises: ParameterAlreadyDeclaredException if the parameter had already been declared.
     |      :raises: InvalidParameterException if the parameter name is invalid.
     |      :raises: InvalidParameterValueException if the registered callback rejects the parameter.
     |  
     |  declare_parameters(self, namespace: str, parameters: List[Union[Tuple[str], Tuple[str, rclpy.parameter.Parameter.Type], Tuple[str, Any, rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor]]], ignore_override: bool = False) -> List[rclpy.parameter.Parameter]
     |      Declare a list of parameters.
     |      
     |      The tuples in the given parameter list shall contain the name for each parameter,
     |      optionally providing a value and a descriptor.
     |      For each entry in the list, a parameter with a name of "namespace.name"
     |      will be declared.
     |      The resulting value for each declared parameter will be returned, considering
     |      parameter overrides set upon node creation as the first choice,
     |      or provided parameter values as the second one.
     |      
     |      The name expansion is naive, so if you set the namespace to be "foo.",
     |      then the resulting parameter names will be like "foo..name".
     |      However, if the namespace is an empty string, then no leading '.' will be
     |      placed before each name, which would have been the case when naively
     |      expanding "namespace.name".
     |      This allows you to declare several parameters at once without a namespace.
     |      
     |      This method, if successful, will result in any callback registered with
     |      :func:`add_on_set_parameters_callback` to be called once for each parameter.
     |      If one of those calls fail, an exception will be raised and the remaining parameters will
     |      not be declared.
     |      Parameters declared up to that point will not be undeclared.
     |      
     |      :param namespace: Namespace for parameters.
     |      :param parameters: List of tuples with parameters to declare.
     |      :param ignore_override: True if overrides shall not be taken into account; False otherwise.
     |      :return: Parameter list with the effectively assigned values for each of them.
     |      :raises: ParameterAlreadyDeclaredException if the parameter had already been declared.
     |      :raises: InvalidParameterException if the parameter name is invalid.
     |      :raises: InvalidParameterValueException if the registered callback rejects any parameter.
     |      :raises: TypeError if any tuple in **parameters** does not match the annotated type.
     |  
     |  describe_parameter(self, name: str) -> rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor
     |      Get the parameter descriptor of a given parameter.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :return: ParameterDescriptor corresponding to the parameter,
     |          or default ParameterDescriptor if parameter had not been declared before
     |          and undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if parameter had not been declared before
     |          and undeclared parameters are not allowed.
     |  
     |  describe_parameters(self, names: List[str]) -> List[rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor]
     |      Get the parameter descriptors of a given list of parameters.
     |      
     |      :param name: List of fully-qualified names of the parameters to describe.
     |      :return: List of ParameterDescriptors corresponding to the given parameters.
     |          Default ParameterDescriptors shall be returned for parameters that
     |          had not been declared before if undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if at least one parameter
     |          had not been declared before and undeclared parameters are not allowed.
     |  
     |  destroy_client(self, client: rclpy.client.Client) -> bool
     |      Destroy a service client created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  destroy_guard_condition(self, guard: rclpy.guard_condition.GuardCondition) -> bool
     |      Destroy a guard condition created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  destroy_node(self)
     |      Destroy the node.
     |      
     |      Frees resources used by the node, including any entities created by the following methods:
     |      
     |      * :func:`create_publisher`
     |      * :func:`create_subscription`
     |      * :func:`create_client`
     |      * :func:`create_service`
     |      * :func:`create_timer`
     |      * :func:`create_guard_condition`
     |  
     |  destroy_publisher(self, publisher: rclpy.publisher.Publisher) -> bool
     |      Destroy a publisher created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  destroy_rate(self, rate: rclpy.timer.Rate) -> bool
     |      Destroy a Rate object created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  destroy_service(self, service: rclpy.service.Service) -> bool
     |      Destroy a service server created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  destroy_subscription(self, subscription: rclpy.subscription.Subscription) -> bool
     |      Destroy a subscription created by the node.
     |      
     |      :return: ``True`` if succesful, ``False`` otherwise.
     |  
     |  destroy_timer(self, timer: rclpy.timer.Timer) -> bool
     |      Destroy a timer created by the node.
     |      
     |      :return: ``True`` if successful, ``False`` otherwise.
     |  
     |  get_client_names_and_types_by_node(self, node_name: str, node_namespace: str) -> List[Tuple[str, List[str]]]
     |      Get a list of discovered service client topics for a remote node.
     |      
     |      :param node_name: Name of a remote node to get service clients for.
     |      :param node_namespace: Namespace of the remote node.
     |      :return: List of tuples.
     |        The fist element of each tuple is the service client name
     |        and the second element is a list of service client types.
     |      :raise NodeNameNonExistentError: If the node wasn't found.
     |      :raise RuntimeError: Unexpected failure.
     |  
     |  get_clock(self) -> rclpy.clock.Clock
     |      Get the clock used by the node.
     |  
     |  get_fully_qualified_name(self) -> str
     |      Get the node's fully qualified name.
     |      
     |      :return: Fully qualified node name.
     |  
     |  get_logger(self)
     |      Get the nodes logger.
     |  
     |  get_name(self) -> str
     |      Get the name of the node.
     |  
     |  get_namespace(self) -> str
     |      Get the namespace of the node.
     |  
     |  get_node_names(self) -> List[str]
     |      Get a list of names for discovered nodes.
     |      
     |      :return: List of node names.
     |  
     |  get_node_names_and_namespaces(self) -> List[Tuple[str, str]]
     |      Get a list of names and namespaces for discovered nodes.
     |      
     |      :return: List of tuples containing two strings: the node name and node namespace.
     |  
     |  get_node_names_and_namespaces_with_enclaves(self) -> List[Tuple[str, str, str]]
     |      Get a list of names, namespaces and enclaves for discovered nodes.
     |      
     |      :return: List of tuples containing three strings: the node name, node namespace
     |          and enclave.
     |  
     |  get_parameter(self, name: str) -> rclpy.parameter.Parameter
     |      Get a parameter by name.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :return: The value for the given parameter name.
     |          A default Parameter will be returned for an undeclared parameter if
     |          undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and the parameter hadn't been declared beforehand.
     |      :raises: ParameterUninitializedException if the parameter is statically typed and
     |          uninitialized.
     |  
     |  get_parameter_or(self, name: str, alternative_value: Optional[rclpy.parameter.Parameter] = None) -> rclpy.parameter.Parameter
     |      Get a parameter or the alternative value.
     |      
     |      If the alternative value is None, a default Parameter with the given name and NOT_SET
     |      type will be returned if the parameter was not declared.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :param alternative_value: Alternative parameter to get if it had not been declared before.
     |      :return: Requested parameter, or alternative value if it hadn't been declared before or is
     |        an uninitialized statically typed parameter.
     |  
     |  get_parameter_type(self, name: str) -> rclpy.parameter.Parameter.Type
     |      Get a parameter type by name.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :return: The type for the given parameter name.
     |          A default Parameter.Type.NOT_SET will be returned for an undeclared parameter
     |          if undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and the parameter hadn't been declared beforehand.
     |  
     |  get_parameter_types(self, names: List[str]) -> List[rclpy.parameter.Parameter.Type]
     |      Get a list of parameter types.
     |      
     |      :param names: Fully-qualified names of the parameters to get, including their namespaces.
     |      :return: The values for the given parameter types.
     |          A default Parameter.Type.NOT_SET will be returned for undeclared parameters
     |          if undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and at least one parameter hadn't been declared beforehand.
     |  
     |  get_parameters(self, names: List[str]) -> List[rclpy.parameter.Parameter]
     |      Get a list of parameters.
     |      
     |      :param names: Fully-qualified names of the parameters to get, including their namespaces.
     |      :return: The values for the given parameter names.
     |          A default Parameter will be returned for undeclared parameters if
     |          undeclared parameters are allowed.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and at least one parameter hadn't been declared beforehand.
     |      :raises: ParameterUninitializedException if at least one parameter is statically typed and
     |          uninitialized.
     |  
     |  get_parameters_by_prefix(self, prefix: str) -> Dict[str, Union[bool, int, float, str, bytes, Sequence[bool], Sequence[int], Sequence[float], Sequence[str], NoneType]]
     |      Get parameters that have a given prefix in their names as a dictionary.
     |      
     |      The names which are used as keys in the returned dictionary have the prefix removed.
     |      For example, if you use the prefix "foo" and the parameters "foo.ping", "foo.pong"
     |      and "bar.baz" exist, then the returned dictionary will have the keys "ping" and "pong".
     |      Note that the parameter separator is also removed from the parameter name to create the
     |      keys.
     |      
     |      An empty string for the prefix will match all parameters.
     |      
     |      If no parameters with the prefix are found, an empty dictionary will be returned.
     |      
     |      :param prefix: The prefix of the parameters to get.
     |      :return: Dict of parameters with the given prefix.
     |  
     |  get_publisher_names_and_types_by_node(self, node_name: str, node_namespace: str, no_demangle: bool = False) -> List[Tuple[str, List[str]]]
     |      Get a list of discovered topics for publishers of a remote node.
     |      
     |      :param node_name: Name of a remote node to get publishers for.
     |      :param node_namespace: Namespace of the remote node.
     |      :param no_demangle: If ``True``, then topic names and types returned will not be demangled.
     |      :return: List of tuples.
     |        The first element of each tuple is the topic name and the second element is a list of
     |        topic types.
     |      :raise NodeNameNonExistentError: If the node wasn't found.
     |      :raise RuntimeError: Unexpected failure.
     |  
     |  get_publishers_info_by_topic(self, topic_name: str, no_mangle: bool = False) -> List[rclpy.topic_endpoint_info.TopicEndpointInfo]
     |      Return a list of publishers on a given topic.
     |      
     |      The returned parameter is a list of TopicEndpointInfo objects, where each will contain
     |      the node name, node namespace, topic type, topic endpoint's GID, and its QoS profile.
     |      
     |      When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic
     |      name for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
     |      When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
     |      ROS topic name conventions.
     |      
     |      `topic_name` may be a relative, private, or fully qualified topic name.
     |      A relative or private topic will be expanded using this node's namespace and name.
     |      The queried `topic_name` is not remapped.
     |      
     |      :param topic_name: the topic_name on which to find the publishers.
     |      :param no_mangle: no_mangle if `true`, `topic_name` needs to be a valid middleware topic
     |          name, otherwise it should be a valid ROS topic name. Defaults to `false`.
     |      :return: a list of TopicEndpointInfo for all the publishers on this topic.
     |  
     |  get_service_names_and_types(self) -> List[Tuple[str, List[str]]]
     |      Get a list of service topics for the node.
     |      
     |      :return: List of tuples.
     |        The first element of each tuple is the service name and the second element is a list of
     |        service types.
     |  
     |  get_service_names_and_types_by_node(self, node_name: str, node_namespace: str) -> List[Tuple[str, List[str]]]
     |      Get a list of discovered service server topics for a remote node.
     |      
     |      :param node_name: Name of a remote node to get services for.
     |      :param node_namespace: Namespace of the remote node.
     |      :return: List of tuples.
     |        The first element of each tuple is the service server name
     |        and the second element is a list of service types.
     |      :raise NodeNameNonExistentError: If the node wasn't found.
     |      :raise RuntimeError: Unexpected failure.
     |  
     |  get_subscriber_names_and_types_by_node(self, node_name: str, node_namespace: str, no_demangle: bool = False) -> List[Tuple[str, List[str]]]
     |      Get a list of discovered topics for subscriptions of a remote node.
     |      
     |      :param node_name: Name of a remote node to get subscriptions for.
     |      :param node_namespace: Namespace of the remote node.
     |      :param no_demangle: If ``True``, then topic names and types returned will not be demangled.
     |      :return: List of tuples.
     |        The first element of each tuple is the topic name and the second element is a list of
     |        topic types.
     |      :raise NodeNameNonExistentError: If the node wasn't found.
     |      :raise RuntimeError: Unexpected failure.
     |  
     |  get_subscriptions_info_by_topic(self, topic_name: str, no_mangle: bool = False) -> List[rclpy.topic_endpoint_info.TopicEndpointInfo]
     |      Return a list of subscriptions on a given topic.
     |      
     |      The returned parameter is a list of TopicEndpointInfo objects, where each will contain
     |      the node name, node namespace, topic type, topic endpoint's GID, and its QoS profile.
     |      
     |      When the `no_mangle` parameter is `true`, the provided `topic_name` should be a valid topic
     |      name for the middleware (useful when combining ROS with native middleware (e.g. DDS) apps).
     |      When the `no_mangle` parameter is `false`, the provided `topic_name` should follow
     |      ROS topic name conventions.
     |      
     |      `topic_name` may be a relative, private, or fully qualified topic name.
     |      A relative or private topic will be expanded using this node's namespace and name.
     |      The queried `topic_name` is not remapped.
     |      
     |      :param topic_name: the topic_name on which to find the subscriptions.
     |      :param no_mangle: no_mangle if `true`, `topic_name` needs to be a valid middleware topic
     |          name, otherwise it should be a valid ROS topic name. Defaults to `false`.
     |      :return: a list of TopicEndpointInfo for all the subscriptions on this topic.
     |  
     |  get_topic_names_and_types(self, no_demangle: bool = False) -> List[Tuple[str, List[str]]]
     |      Get a list topic names and types for the node.
     |      
     |      :param no_demangle: If ``True``, then topic names and types returned will not be demangled.
     |      :return: List of tuples.
     |        The first element of each tuple is the topic name and the second element is a list of
     |        topic types.
     |  
     |  has_parameter(self, name: str) -> bool
     |      Return True if parameter is declared; False otherwise.
     |  
     |  remove_on_set_parameters_callback(self, callback: Callable[[List[rclpy.parameter.Parameter]], rcl_interfaces.msg._set_parameters_result.SetParametersResult]) -> None
     |      Remove a callback from list of callbacks.
     |      
     |      Calling this function will remove the callback from self._parameter_callbacks list.
     |      
     |      :param callback: The function that is called whenever parameters are set for the node.
     |      :raises: ValueError if a callback is not present in the list of callbacks.
     |  
     |  remove_waitable(self, waitable: rclpy.waitable.Waitable) -> None
     |      Remove a Waitable that was previously added to the node.
     |      
     |      :param waitable: The Waitable to remove.
     |  
     |  resolve_service_name(self, service: str, *, only_expand: bool = False) -> str
     |      Return a service name expanded and remapped.
     |      
     |      :param service: service name to be expanded and remapped.
     |      :param only_expand: if `True`, remapping rules won't be applied.
     |      :return: a fully qualified service name,
     |          result of applying expansion and remapping to the given `service`.
     |  
     |  resolve_topic_name(self, topic: str, *, only_expand: bool = False) -> str
     |      Return a topic name expanded and remapped.
     |      
     |      :param topic: topic name to be expanded and remapped.
     |      :param only_expand: if `True`, remapping rules won't be applied.
     |      :return: a fully qualified topic name,
     |          result of applying expansion and remapping to the given `topic`.
     |  
     |  set_descriptor(self, name: str, descriptor: rcl_interfaces.msg._parameter_descriptor.ParameterDescriptor, alternative_value: Optional[rcl_interfaces.msg._parameter_value.ParameterValue] = None) -> rcl_interfaces.msg._parameter_value.ParameterValue
     |      Set a new descriptor for a given parameter.
     |      
     |      The name in the descriptor is ignored and set to **name**.
     |      
     |      :param name: Fully-qualified name of the parameter to set the descriptor to.
     |      :param descriptor: New descriptor to apply to the parameter.
     |      :param alternative_value: Value to set to the parameter if the existing value does not
     |          comply with the new descriptor.
     |      :return: ParameterValue for the given parameter name after applying the new descriptor.
     |      :raises: ParameterNotDeclaredException if parameter had not been declared before
     |          and undeclared parameters are not allowed.
     |      :raises: ParameterImmutableException if the parameter exists and is read-only.
     |      :raises: ParameterValueException if neither the existing value nor the alternative value
     |          complies with the provided descriptor.
     |  
     |  set_parameters(self, parameter_list: List[rclpy.parameter.Parameter]) -> List[rcl_interfaces.msg._set_parameters_result.SetParametersResult]
     |      Set parameters for the node, and return the result for the set action.
     |      
     |      If any parameter in the list was not declared beforehand and undeclared parameters are not
     |      allowed for the node, this method will raise a ParameterNotDeclaredException exception.
     |      
     |      Parameters are set in the order they are declared in the list.
     |      If setting a parameter fails due to not being declared, then the
     |      parameters which have already been set will stay set, and no attempt will
     |      be made to set the parameters which come after.
     |      
     |      If undeclared parameters are allowed, then all the parameters will be implicitly
     |      declared before being set even if they were not declared beforehand.
     |      Parameter overrides are ignored by this method.
     |      
     |      If a callback was registered previously with :func:`add_on_set_parameters_callback`, it
     |      will be called prior to setting the parameters for the node, once for each parameter.
     |      If the callback prevents a parameter from being set, then it will be reflected in the
     |      returned result; no exceptions will be raised in this case.
     |      For each successfully set parameter, a :class:`ParameterEvent` message is
     |      published.
     |      
     |      If the value type of the parameter is NOT_SET, and the existing parameter type is
     |      something else, then the parameter will be implicitly undeclared.
     |      
     |      :param parameter_list: The list of parameters to set.
     |      :return: The result for each set action as a list.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and at least one parameter in the list hadn't been declared beforehand.
     |  
     |  set_parameters_atomically(self, parameter_list: List[rclpy.parameter.Parameter]) -> rcl_interfaces.msg._set_parameters_result.SetParametersResult
     |      Set the given parameters, all at one time, and then aggregate result.
     |      
     |      If any parameter in the list was not declared beforehand and undeclared parameters are not
     |      allowed for the node, this method will raise a ParameterNotDeclaredException exception.
     |      
     |      Parameters are set all at once.
     |      If setting a parameter fails due to not being declared, then no parameter will be set set.
     |      Either all of the parameters are set or none of them are set.
     |      
     |      If undeclared parameters are allowed for the node, then all the parameters will be
     |      implicitly declared before being set even if they were not declared beforehand.
     |      
     |      If a callback was registered previously with :func:`add_on_set_parameters_callback`, it
     |      will be called prior to setting the parameters for the node only once for all parameters.
     |      If the callback prevents the parameters from being set, then it will be reflected in the
     |      returned result; no exceptions will be raised in this case.
     |      For each successfully set parameter, a :class:`ParameterEvent` message is published.
     |      
     |      If the value type of the parameter is NOT_SET, and the existing parameter type is
     |      something else, then the parameter will be implicitly undeclared.
     |      
     |      :param parameter_list: The list of parameters to set.
     |      :return: Aggregate result of setting all the parameters atomically.
     |      :raises: ParameterNotDeclaredException if undeclared parameters are not allowed,
     |          and at least one parameter in the list hadn't been declared beforehand.
     |  
     |  undeclare_parameter(self, name: str)
     |      Undeclare a previously declared parameter.
     |      
     |      This method will not cause a callback registered with
     |      :func:`add_on_set_parameters_callback` to be called.
     |      
     |      :param name: Fully-qualified name of the parameter, including its namespace.
     |      :raises: ParameterNotDeclaredException if parameter had not been declared before.
     |      :raises: ParameterImmutableException if the parameter was created as read-only.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from rclpy.node.Node:
     |  
     |  clients
     |      Get clients that have been created on this node.
     |  
     |  context
     |      Get the context associated with the node.
     |  
     |  default_callback_group
     |      Get the default callback group.
     |      
     |      If no other callback group is provided when the a ROS entity is created with the node,
     |      then it is added to the default callback group.
     |  
     |  guards
     |      Get guards that have been created on this node.
     |  
     |  publishers
     |      Get publishers that have been created on this node.
     |  
     |  services
     |      Get services that have been created on this node.
     |  
     |  subscriptions
     |      Get subscriptions that have been created on this node.
     |  
     |  timers
     |      Get timers that have been created on this node.
     |  
     |  waitables
     |      Get waitables that have been created on this node.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from rclpy.node.Node:
     |  
     |  __dict__
     |      dictionary for instance variables
     |  
     |  __weakref__
     |      list of weak references to the object
     |  
     |  executor
     |      Get the executor if the node has been added to one, else return ``None``.
     |  
     |  handle
     |      Get the handle to the underlying `rcl_node_t`.
     |      
     |      Cannot be modified after node creation.
     |      
     |      :raises: AttributeError if modified after creation.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from rclpy.node.Node:
     |  
     |  PARAM_REL_TOL = 1e-06
    
    class Images(builtins.object)
     |  Images(color: numpy.ndarray[typing.Any, numpy.dtype[float]], depth: numpy.ndarray[typing.Any, numpy.dtype[float]], intrinsics: numpy.ndarray[typing.Any, numpy.dtype[float]], xyz_rgb: numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]], xyz_rgb_frame: str) -> None
     |  
     |  This is a datastructure to hold color/depth images and intrinsics, as well as the pointcloud.
     |  It's a chunky boy, don't hold too many in memory at once.
     |  
     |  Methods defined here:
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, color: numpy.ndarray[typing.Any, numpy.dtype[float]], depth: numpy.ndarray[typing.Any, numpy.dtype[float]], intrinsics: numpy.ndarray[typing.Any, numpy.dtype[float]], xyz_rgb: numpy.ndarray[typing.Any, numpy.dtype[numpy.float32]], xyz_rgb_frame: str) -> None
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables
     |  
     |  __weakref__
     |      list of weak references to the object
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __annotations__ = {'color': numpy.ndarray[typing.Any, numpy.dtype[floa...
     |  
     |  __dataclass_fields__ = {'color': Field(name='color',type=numpy.ndarray...
     |  
     |  __dataclass_params__ = _DataclassParams(init=True,repr=True,eq=True,or...
     |  
     |  __hash__ = None
     |  
     |  __match_args__ = ('color', 'depth', 'intrinsics', 'xyz_rgb', 'xyz_rgb_...

FUNCTIONS
    main(args=None)

DATA
    CAMERA_FRAME_TO_ROBOT_FRAME_EXTRINSICS = array([[-0.6905175 , -0.50300...
    COLOR_CAMERA_FRAME_ID = 'camera_color_optical_frame'
    COLOR_CAMERA_INFO_TOPIC_NAME = '/camera/realsense2_camera_node/color/i...
    COLOR_CAMERA_TOPIC_NAME = '/camera/realsense2_camera_node/color/image_...
    DEPTH_CAMERA_FRAME_ID = 'camera_depth_optical_frame'
    DEPTH_CAMERA_INFO_TOPIC_NAME = '/camera/realsense2_camera_node/depth/i...
    DEPTH_CAMERA_TOPIC_NAME = '/camera/realsense2_camera_node/depth/image_...
    DEPTH_SCALE = 0.001
    Optional = typing.Optional
        Optional[X] is equivalent to Union[X, None].
    
    POINTCLOUD_TOPIC_NAME = '/camera/pointcloud'
    Tuple = typing.Tuple
        Deprecated alias to builtins.tuple.
        
        Tuple[X, Y] is the cross-product type of X and Y.
        
        Example: Tuple[T1, T2] is a tuple of two elements corresponding
        to type variables T1 and T2.  Tuple[int, float, str] is a tuple
        of an int, a float and a string.
        
        To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].
    
    WORLD_FRAME_ID = 'map'

FILE
    /home/mz/mycobot_client/mycobot_client_2/mycobot_client_2/camera_calculator.py


